#!/usr/bin/env ruby

require 'shout_trace'

require 'webrick'
require 'webrick/httpserver'

module ShoutTrace


class Error < Exception; end
class ProgramError < Error; end

# Run the ShoutTrace::Server on your local development box.
#
# Works with vim, emacsclient, bbedit, or mate (Textmate).
#
# vim:
#    
#    vim --servername VIM # starts a vim server
#    SHOUT_TRACE_EDITOR="Vim" ruby -I path/to/shout_trace/lib -r shout_trace/server -e 'ShoutTrace::Server.new.run'
#   
# emacs:
#
#    emacs # with (start-server) in ~/.emacsrc
#    SHOUT_TRACE_EDITOR="Emacs" ruby -I path/to/shout_trace/lib  -r shout_trace/server -e 'ShoutTrace::Server.new.run'
#
# bbedit:
#    
#    SHOUT_TRACE_EDITOR="BBEdit" ruby -I path/to/shout_trace/lib -r shout_trace/server -e 'ShoutTrace::Server.new.run'
#
# Textmate:
#    
#    SHOUT_TRACE_EDITOR="mate" ruby -I path/to/shout_trace/lib -r shout_trace/server -e 'ShoutTrace::Server.new.run'
#

# For more advanced configuration, create a ruby script as follows:
#
#   | > cat ~/bin/my_shout_trace
#   | #!/usr/bin/env ruby
#   |
#   | $:.unshift 'path/to/shout_trace/lib'
#   | 
#   | require 'shout_trace/server'
#   | 
#   | editor, args = ARGV
#   | 
#   | ENV['SHOUT_TRACE_EDITOR'] = editor || "Emacs"
#   | ENV['SHOUT_TRACE_EMACSCLIENT'] = "emacsclient.emacs-snapshot"
#   | 
#   | LOCAL_SCM_ROOT = "#{ENV['HOME']}/path-to-your-local-checkouts"
#   | ENV['SHOUT_TRACE_ALLOW'] = LOCAL_SCM_ROOT
#   | # Optional:
#   | ENV['SHOUT_TRACE_DENY'] = "#{ENV['HOME']}/local"
#   | 
#   | sts = ShoutTrace::Server.new
#   | sts.filter << [ '/usr/lib/ruby/', "~/local/ruby/generic/lib/ruby/" ]
#   | sts.allow << '~/local/ruby/generic'
#   | sts.log['development.log', 'logs/development.log']
#   | sts.run
#
#
class Server
  # The hostname to bind the server on.
  # Defaults to HOST.
  attr_accessor :host

  # The port to bind the server.
  # Defaults to PORT.
  attr_accessor :port

  # The WEBrick::HTTPServer object.
  attr_accessor :server

  # The ShoutTrace::Annotator use to annotate logs and decode 
  # file:line requests.
  attr_accessor :annotator

  # A ShoutTrace::EditorService object use to open the file
  # for local editing.
  attr_accessor :editor

  # A hash of log names and local file names that
  # can be annotated.
  attr_accessor :log

  # If true, the contents of the file is shown in the browser,
  # Otherwise, the browser is redirected back to the referring page.
  attr_accessor :show_file

  # If true, the contents of the file is shown is a separate window.
  attr_accessor :show_file_in_window

  # List of file name patterns that are allows to be shown.
  attr_accessor :allow

  # List of file name patterns that are not allowed to be shown.
  attr_accessor :deny

  # List of functions that are use to remap file names to
  # local paths.  Useful for incomplete filenames sometimes
  # generated by ERB, or mapping remote file paths
  # to local file paths.
  #
  # For example:
  #
  #   # Translate any references to remote gems to ~/local/gems:
  #   sts.filter << lambda do | file, req |
  #     file.sub(/.*\/gems\/, File.expand_path('~/local/gems'))
  #   end
  #
  # Filters can also be specified as [ search, replace ] pairs:
  #
  #   # Translate any references to core ruby files to personal ruby build.
  #   sts.filter << [ '/usr/lib/ruby/', '~/local/ruby/lib' ]
  #
  attr_accessor :filter

  # Supplied options.
  attr_accessor :opt

  def initialize
    @host = HOST
    @port = PORT
    @annotator = Annotator.new
    @editor = EditorService.new
    @log = { }
    @allow = [ ]
    @deny = [ ]
    @filter = [ ]
    @show_file = true
    @show_file_in_window = false
    @opt = { }
    yield self if block_given?
  end
  
  
  # Start the server.
  # This should be called after the Server has been configured.
  def run
    @annotator.link_target = nil unless show_file_in_window

    # Create a HTTP server.
    access_log_stream = File.open('/dev/null', 'w')
    access_log = [ [ access_log_stream, WEBrick::AccessLog::COMBINED_LOG_FORMAT ] ]
    @server = WEBrick::HTTPServer.new(
                                      :Host => host,
                                      :Port => port,
                                      :AccessLog => access_log
                                      )


    # Rewrite filters as Procs
    @filter = @filter.compact.collect do | filter |
      if filter.kind_of?(Array)
        rx = filter[0]
        rep = filter[1]
        rx = Regexp.new("^#{rx}") unless rx.kind_of?(Regexp)
        filter = Proc.new do | file, req |
          # STDERR.puts "file = #{file.inspect}"
          # STDERR.puts "rx = #{rx.inspect}"
          # STDERR.puts "rep = #{rep.inspect}"
          file.sub(rx, rep)
        end
      end
      filter
    end

    # Allow files to be shown?
    self.allow += (ENV['SHOUT_TRACE_ALLOW'] || '').split(/:/)

    # Deny files to be shown?
    self.deny  += (ENV['SHOUT_TRACE_DENY'] || '').split(/:/)
    
    # Rewrite allow/deny patterns as Regex.
    @allow = @allow.compact.collect do | pat |
      unless pat.kind_of?(Regexp)
        pat = File.expand_path(pat)
        pat = /^#{pat}/
      end
      pat
    end
    @deny = @deny.compact.collect do | pat |
      unless pat.kind_of?(Regexp)
        pat = File.expand_path(pat)
        pat = /^#{pat}/
      end
      pat
    end

    # Handle files.
    @server.mount_proc('/shout_trace/file/') do | req, res |
      # STDERR.puts "req.path = #{req.path.inspect}"

      path = req.path
      file, line = @annotator.unmake_link(path)
      
      raise(Error, "no file for #{path.inspect}") unless file
      raise(Error, "no line for #{path.inspect}") unless line
    
      file = file.gsub('//', '/')
  
      begin
        file_new = nil
        pass = -1
        # Keep applying filters until file does not change.
        while file_new != file && (pass += 1) < 10
          file_new = file

          # Apply filters.
          @filter.each do | filter |
            file_copy = file.clone
            if result = filter.call(file_copy, req)
              # STDERR.puts "filter: #{file.inspect} => #{file_copy.inspect} #{result.inspect}"
              result = result.gsub('//', '/')
              file = File.expand_path(result)
            end
          end
        end

        # Make file path absolute.
        file = File.expand_path(file)

        # Allow/deny?
        allow = false
        @allow.each do | pat | 
          # STDERR.puts "allow: matching #{file.inspect} with #{pat.inspect}"
          if pat.match(file)
            # STDERR.puts "allow: matched #{file.inspect} with #{pat.inspect}"
            allow = true
            break
          end
        end
        @deny.each do | pat | 
          # STDERR.puts "deny: matching #{file.inspect} with #{pat.inspect}"
          if pat.match(file)
            # STDERR.puts "deny: matched #{file.inspect} with #{pat.inspect}"
            allow = false
            break
          end
        end
        raise(Error, "Access Denied to #{file.inspect}") unless allow

        raise(Error, "File #{file.inspect} does not exist") unless File.exist?(file)

        # Process the file:line request.
        handle_file_line(req, res, file, line)

        # Show the file in the browser, or redirect back to referer.
        if show_file
          annotate_file(req, res, file, :line => line)
        else
          redirect_to_referer(req, res)
        end

      rescue WEBrick::HTTPStatus::Redirect => err
        # Nothing

      rescue ::ShoutTrace::ProgramError => err
        STDERR.puts "ERROR: Cannot handle #{req.path.inspect}: #{err.inspect}\n#{err.backtrace.join("\n")}"
        annotate_file(req, res, file, :line => line, :msg => "Problem handling #{req.path.inspect}: #{err.inspect}")

      rescue Exception => err
        STDERR.puts "ERROR: Cannot handle #{req.path.inspect}: #{err.inspect}\n#{err.backtrace.join("\n")}"
        body = @annotator.annotate(err.backtrace.join("\n"), :html => true, :abspath => true)
        render_html(req, res, :title => "Error - #{err.inspect}", :body => body)
      end
    end

    # List logs.
    @log = @log.keys.inject({ }) do | h, k | 
      log = @log[k]
      log = { :file => log } unless log.kind_of?(Hash)
      log[:name] ||= k
      h[k] = log
      h
    end
    @server.mount_proc('/shout_trace/log') do | req, res |
      lines = @log.keys.sort.collect do | key |
        v = @log[key]
        "<tr><td><a href=\"/shout_trace/log/#{key}\">#{h key}</a></td><td>#{h v[:file]}</td></tr>"
      end
      lines = [ '<table>', *lines ] << '</table>'

      render_html(req, res, :title => 'Logs', :body => lines.join("\n"))
    end

    # Attach each log.
    log.each_pair do | key, log |
      path_base = "/shout_trace/log/#{key}"
      path_base_match = /^#{path_base}/

      @server.mount_proc(path_base) do | req, res |
        file = req.path.sub(path_base_match, '')

        # Read last n lines of file.
        opts = { :annotate => true }
        unless req.request_uri.query && ! req.request_uri.query.empty?
          opts.merge!({ :n => 40, :prev => 1, :pos => -1 })
        end
        annotate_file(req, res, log[:file], opts)
      end
    end
    
    trap("INT") { stop }
    
    @server.start
  end
  

  # Stop the server.
  def stop
    @server && @server.shutdown
    @server = nil
    0
  end


  # Can be override by subclasses to process
  # file:line open request.
  def handle_file_line(req, res, file, line)
    editor.execute(self, req, res, file, line)
  end


  def log_url(name)
    "/shout_trace/log/#{name}"
  end


  def log_nav(current = nil)
    log.keys.sort.collect do | name |
      file = log[name]
      "<a href=\"#{log_url(name)}\" title=\"#{file[:file]}\">#{h((name == current || file[:file] == current) ? "[#{name}]" : name)}</a>"
    end.join('&nbsp;')   
  end
 

  # Generic build a HTML page.
  def render_html(req, res, opt = { })
    out = <<-"END"
    <html>
      <head>
        <title>ShoutTrace - #{h opt[:title]}</title>
      </head>
      <body>
        <h1>#{h opt[:title]}</h1>
        #{opt[:body]}
      </body>
    </html>
    END

    # STDERR.puts "out = #{out}"
    res['Content-Type'] = 'text/html'
    res.body = out
  end


  # Builds a page that immediately redirects back
  # to the referer.
  def redirect_to_referer(req, res)
    # STDERR.puts "referrer = #{req['Referer'].inspect}"
    referer = req['Referer']
    res['Content-Type'] = 'text/html'
    res.body = <<-"EOF"
<html>
  <head>
    <meta http-equiv="refresh" content="1;url=#{referer}" />
  </head>
  <body>
    <script type="text/javascript">
//<!--
      history.go(-1)
//-->
    </script>
    <a href="#{referer}">#{h referer}</a>
  </body>
</html
    EOF
  end


  # Annotates a file.
  def annotate_file(req, res, file, opt = { })
    # STDERR.puts "annotate_file(#{file.inspect})"

    # Copy request parameters to opts.
    query = req.request_uri.query || ''
    query = Hash[*query.split(/[;&]/).collect{|x| x.empty? ? [nil, nil] : x.split('=')}.flatten] || { }
    query = query.keys.inject({ }) { | h, k | h[k.intern] = query[k].to_i; h }
    # STDERR.puts "query = #{query.inspect}"
    opt.merge!(query)
    # STDERR.puts "opt = #{opt.inspect}"

    # STDERR.puts "opt = #{opt.inspect}"

    # Read lines from file.
    if opt[:prev]
      lines = read_lines_before(file, opt[:pos] || 0, opt[:n], opt[:n] * 3 / 4) # Move by 3/4 page.
    else
      lines = read_lines_at(file, opt[:pos] || 0, opt[:n])
    end
    
    # Determine navigation positions.
    pos = lines[0]
    pos = pos ? pos[0] : 0
    pos_next = lines[lines.size * 3 / 4]
    pos_next = pos_next ? pos_next[0] : 0 # Move by 3/4 page.
    
    # Collect output into new array of lines.
    lineno = 0
    lines = lines.collect do | line |
      lineno += 1
      pos_line = line[0]
      str = line[1]
      
      # Annotate line for stack traces?
      if opt[:annotate]
        str = @annotator.annotate(str, :html => true)
      else
        str = html_escape(str)
      end
      
      if opt[:line]
        ln = '%6d ' % lineno.to_i
        ln = html_escape(ln)
      else
        ln = '%8d' % pos_line.to_i
        ln = '#'
        md = /^(\s*)(\S+)$/.match(ln)
        spc, ln = md[1], md[2]
        ln = "#{h spc}<a href=\"#{req.request_uri.path}?pos=#{pos_line};n=#{opt[:n]};\" title=\"Go to this line\">#{h ln}</a>"
      end

      str = "#{opt[:line] ? html_escape(lineno == opt[:line] ? '=> ' : '   ') : ''}<a name=\"#{lineno}\">#{ln}</a>&nbsp;<a name=\"P#{pos_line}\">#{str}</a>"
      
      # Highlight line?
      if lineno == opt[:line]
        str = "<span style=\"color: orange;\">#{str}</span>"
      end
      
      str
    end
    
    # Create navigation?
    nav = ''
    if opt[:n]
      nav = [ 
             { :text => "|<", :title => "First", :pos => 0,           :prev => nil, :play => nil },
             { :text => "<<", :title => "Prev",  :pos => pos,         :prev => 1,   :play => nil},
             { :text => ">>", :title => "Next",  :pos => pos_next,    :prev => nil, :play => nil },
             { :text => ">|", :title => "Last",  :pos => - 1,         :prev => 1,   :play => nil },

             query[:play] ? 
             { :text => "||", :title => "Pause", :pos => -1, :prev => 1, :play => nil } :
             { :text => "=>", :title => "Play",  :pos => -1, :prev => 1, :play => 1 } ,
            ]
      
      nav = nav.collect do | nav |
        title = nav[:title] || ''
        nav.delete(:title)
        text = nav[:text] || ''
        nav.delete(:text)
        nav[:n]   ||= opt[:n]   if opt[:n]
        q = query.merge(nav)
        uri = "#{req.request_uri.path}?#{q.keys.collect { | k | nav[k] && "#{k}=#{nav[k]};"}}"
        "<a href=\"#{uri}\" title=\"#{title}\">#{h text}</a>"
      end

      nav = nav.collect { | nav | "<td>#{nav}</td>" }
      nav = "<table><tr>#{nav}</tr></table><br />"
    end
    # STDERR.puts "nav = #{nav.inspect}"

    # Generate page.
    out = <<-"END"
    <html>
      <head>
        <title>ShoutTrace - #{file}</title> 
        #{query[:play] ? "<meta http-equiv=\"refresh\" content=\"5;url=#{req.request_uri}\" />" : ''}
      </head>
      <body>
        <h1>#{html_escape(opt[:msg] || '')}</h1>
        #{h file}<br />
        #{log_nav(file)}<br />
        #{nav}
        <code>
        #{lines.join("\n")}
        </code>
      </body>
    </html>
    END

    # STDERR.puts "out = #{out}"
    res['Content-Type'] = 'text/html'
    res.body = out

    out
  end

  
  def read_lines_at(file, pos, n = nil)
    # STDERR.puts "read_lines_at(#{file.inspect}, #{pos.inspect}, #{n.inspect})"

    # Read lines from file.
    lines = [ ]
    File.open(file) do | fh |
      if pos >= 0
        fh.seek(pos, IO::SEEK_SET) rescue nil
      else
        fh.seek(pos, IO::SEEK_END) rescue nil
        fh.readline
      end

      # Read until pos_end or eof.
      until fh.eof? or (n && lines.size >= n)
        line_pos = fh.pos 
        line = [ line_pos, fh.readline ]
        # STDERR.puts "read = #{line.inspect}"
        lines << line
      end
    end

    lines
  end


  def read_lines_before(file, pos, n, back, blksize = 8192)
    # STDERR.puts "read_lines_before(#{file.inspect}, #{pos.inspect}, #{n.inspect}, #{back.inspect}))"
    lines = [ ] 
    back ||= n   

    File.open(file) do | fh |
      if pos < 0
        fh.seek(pos, IO::SEEK_END) rescue nil
        fh.readline
        pos = fh.pos
      end

      pos_end = pos
      while pos >= 0 && lines.size < back
        lines_buf = [ ]
        
        # Backup by a block.
        pos -= blksize
        
        # When to stop reading lines.
        pos_stop = lines[0] ? lines[0][0] : pos_end
        
        # If at beginning of file?
        pos_line = pos
        if pos_line <= 0 
          pos_line = 0
          fh.seek(pos_line, IO::SEEK_SET) rescue nil
        else
          # If not at beginning of file,
          # assume we are at in the middle of a line.
          fh.seek(pos_line, IO::SEEK_SET) rescue nil
          fh.readline 
         end

        # STDERR.puts "seeked to #{pos_line}"
        # STDERR.puts "stop at #{pos_stop}"
        until fh.eof?
          pos_line = fh.pos
          break if pos_line >= pos_stop
          line = [ pos_line, fh.readline ]
          # STDERR.puts "read = #{line.inspect}"
          lines_buf << line
        end

        # Insert new lines read.
        lines = lines_buf + lines

      end

      # Truncate.
      if lines.size > back
        lines = lines[- back .. -1]
      end
      
      # Fill out the buffer.
      if lines.size < n
        fh.seek(pos_end, IO::SEEK_SET) rescue nil
        until fh.eof?
          break if lines.size >= n
          pos_line = fh.pos
          line = [ pos_line, fh.readline ]
          lines << line
        end
      end
    end

    lines
  end


  def html_escape(*args)
    @annotator.html_escape(*args)
  end
  alias :h :html_escape



#################################################################################
# Setup.
# 

  EMPTY_HASH = { }.freeze

  # Helper method for filters.
  # Extracts URL query parameters into a Hash.
  def request_query(req)
    (req.
      request_uri.
      query || ''
      ).
      split(/[;&]/).
      map{|x| x.split('=', 2) }.
      inject({ }) { | h, kv | h[kv[0].to_sym] = kv[1]; h }
  end

end # class


# EditorService remotely
# opens a file using a editor's
# notion of an edit server and client.
# For example: 
# emacs can be a edit server for emacsclient,
# vim can also be an edit server.
#
class EditorService
  # The type of editor.
  attr_accessor :editor

  # The program to use.
  attr_accessor :prog

  # If true, the editor command line is actually run.
  # Useful for debugging.
  attr_accessor :dry_run

  # The command line executed for each file:line request.
  attr_accessor :cmd_line

  @@editor_prog = {
    'vim'    => "vim",
    'emacs'  => "emacsclient",
    'bbedit' => "bbedit",
    'mate' => "mate"
  }

  @@editor_cmd_line = {
    'vim'    => '(#{prog} --serverlist | grep -sq VIM) && #{prog} --remote-silent +#{line} \'#{file}\'',
    'emacs'  => '#{prog} --no-wait +#{line} \'#{file}\'',
    'bbedit' => '#{prog} +#{line} \'#{file}\'',
    'mate' => '#{prog} --async --line #{line} \'#{file}\''
  }

  def initialize(editor = nil)
    @editor = (editor || ENV['SHOUT_TRACE_EDITOR'] || 'vim').downcase
    @prog = @@editor_prog[@editor] || ENV['SHOUT_TRACE_EDITOR']
    @prog = ENV["SHOUT_TRACE_#{@prog.upcase}"] || @prog 
    @cmd_line = ENV['SHOUT_TRACE_CMD_LINE'] || @@editor_cmd_line[@editor]
    raise(Error, "Please supply a command line template for editor: #{@editor}.") unless @cmd_line
    @dry_run = false
  end

  
  # Subclasses can override this method.
  def execute(srv, req, res, file, line)
    file = File.expand_path(File.dirname(file)) + '/' + File.basename(file)
    file = File.expand_path(file)
    open_file(file, line)
  end


  # Subclasses can override this method.
  def open_file(file, line)
    cmd = cmd_line.gsub(/['"\\]/) { |x| "\\" + x }
    cmd = '"' + cmd + '"'
    cmd = instance_eval cmd
    run(cmd)
  end


  # Runs a shell command.
  def run(cmd)
    STDERR.puts "#{$0}: Run: #{cmd.inspect}"
    unless @dry_run
      raise(ProgramError, "Cannot run #{cmd.inspect}") unless system(cmd) 
    end
  end

end # class

end # module


# Sample log for http://localhost:3333/shout_trace/log/shout_trace_sample
__END__


ActiveRecord::StatementInvalid (PGError: ERROR:  relation "log_summaries" does not exist
: SELECT count(log_summaries.id)
FROM log_summaries log_summaries
WHERE (1=1) ):
    /usr/lib/ruby/gems/1.8/gems/activerecord-1.13.2/lib/active_record/connection_adapters/abstract_adapter.rb:88:in `log'
    /usr/lib/ruby/gems/1.8/gems/activerecord-1.13.2/lib/active_record/connection_adapters/postgresql_adapter.rb:137:in `execute'
    /usr/lib/ruby/gems/1.8/gems/activerecord-1.13.2/lib/active_record/connection_adapters/postgresql_adapter.rb:351:in `select'
    /usr/lib/ruby/gems/1.8/gems/activerecord-1.13.2/lib/active_record/connection_adapters/postgresql_adapter.rb:122:in `select_one'
    /usr/lib/ruby/gems/1.8/gems/activerecord-1.13.2/lib/active_record/connection_adapters/abstract/database_statements.rb:16:in `select_value'
    /usr/lib/ruby/gems/1.8/gems/activerecord-1.13.2/lib/active_record/base.rb:518:in `count_by_sql'
    components/generic/list_controller.rb:400:in `execute_query'
    components/generic/list_controller.rb:100:in `process_params'
    components/generic/list_controller.rb:49:in `index'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:853:in `send'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:853:in `perform_action_without_filters'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/filters.rb:332:in `perform_action_without_benchmark'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/benchmarking.rb:69:in `perform_action_without_rescue'
    /usr/lib/ruby/1.8/benchmark.rb:293:in `measure'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/benchmarking.rb:69:in `perform_action_without_rescue'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/rescue.rb:82:in `perform_action'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:369:in `send'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:369:in `process_without_session_management_support'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/session_management.rb:116:in `process'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:300:in `process'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/components.rb:55:in `component_response'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/components.rb:42:in `render_component_as_string'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/components.rb:81:in `component_logging'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/components.rb:41:in `render_component_as_string'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_view/base.rb:268:in `send'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_view/base.rb:268:in `compile_and_render_template'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_view/base.rb:244:in `render_template'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_view/base.rb:205:in `render_file'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:655:in `render_file'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:595:in `render_with_no_layout'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:647:in `render_action'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:612:in `render_with_no_layout'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/layout.rb:217:in `render_without_benchmark'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/benchmarking.rb:53:in `render'
    /usr/lib/ruby/1.8/benchmark.rb:293:in `measure'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/benchmarking.rb:53:in `render'
    app/controllers/content_controller.rb:56:in `show_plain_view'
    app/controllers/content_controller.rb:30:in `appear'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:853:in `send'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:853:in `perform_action_without_filters'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/filters.rb:332:in `perform_action_without_benchmark'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/benchmarking.rb:69:in `perform_action_without_rescue'
    /usr/lib/ruby/1.8/benchmark.rb:293:in `measure'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/benchmarking.rb:69:in `perform_action_without_rescue'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/rescue.rb:82:in `perform_action'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:369:in `send'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/base.rb:369:in `process_without_session_management_support'
    /usr/lib/ruby/gems/1.8/gems/actionpack-1.11.2/lib/action_controller/session_management.rb:116:in `process'
    /usr/lib/ruby/gems/1.8/gems/rails-1.0.0/lib/dispatcher.rb:38:in `dispatch'

 
